<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Axiom Frontier</title>
  <link rel="stylesheet" href="/style.css" />
</head>
<body>
  <main class="shell">
    <header class="hero">
      <div>
        <p class="eyebrow">Text-First MMO</p>
        <h1>Axiom Frontier</h1>
        <p class="sub">自然语言交互 · LLM 驱动 · 城市规则由统治者/城主决定</p>
      </div>
      <div class="status" id="status">准备就绪</div>
    </header>

    <div class="layout">
      <section class="map-panel">
        <div class="map-header">
          <div>
            <div class="map-title">世界地图</div>
            <div class="map-sub">点击地图可移动，绿色为你，蓝色为NPC，橙色为其他玩家</div>
          </div>
          <button id="refreshMap" class="ghost">刷新地图</button>
        </div>
        <div class="map-wrapper">
          <canvas id="mapCanvas" width="640" height="480"></canvas>
          <div class="map-controls">
            <button id="mapFocus" class="ghost sm">定位到玩家</button>
            <button id="mapFit" class="ghost sm">自适应</button>
            <button id="mapReset" class="ghost sm">重置</button>
          </div>
          <div class="map-hint">滚轮缩放 · 拖拽平移 · 点击移动 · 双击自适应</div>
          <div class="map-tooltip" id="mapTooltip"></div>
        </div>
      </section>

      <section class="side">
        <section class="panel">
          <div class="row">
            <label class="field">
              <span>玩家 ID</span>
              <input id="playerId" type="text" value="demo" />
            </label>
            <label class="field">
              <span>服务器</span>
              <input id="server" type="text" value="" placeholder="留空即当前域名" />
            </label>
            <button id="health" class="ghost">健康检查</button>
          </div>

          <label class="field">
            <span>输入（自然语言）</span>
            <textarea id="input" rows="3" placeholder="例如：向北走 / 提现50 / 环顾四周"></textarea>
          </label>

          <div class="row">
            <button id="send">发送行动</button>
            <button id="clear" class="ghost">清空输出</button>
            <button id="refreshNpc" class="ghost">刷新 NPC</button>
          </div>
        </section>

        <section class="grid">
          <div class="card">
            <div class="card-title">行动反馈</div>
            <div class="summary" id="summary">等待输入…</div>
            <div class="sensory" id="sensory">
              <div><strong>视觉</strong><span id="vision"></span></div>
              <div><strong>听觉</strong><span id="audio"></span></div>
              <div><strong>嗅觉</strong><span id="smell"></span></div>
              <div><strong>触觉</strong><span id="touch"></span></div>
            </div>
          </div>
          <div class="card">
            <div class="card-title">状态</div>
            <div class="stats" id="stats">
              <div><strong>生命值</strong><span id="hp">-</span></div>
              <div><strong>金钱</strong><span id="credits">-</span></div>
              <div><strong>饥饿</strong><span id="hunger">-</span></div>
              <div><strong>热度</strong><span id="heat">-</span></div>
              <div><strong>通缉</strong><span id="wanted">-</span></div>
              <div><strong>位置</strong><span id="location">-</span></div>
            </div>
            <div class="card-sub" id="locationDetail">-</div>
            <div class="chips" id="neighbors"></div>
            <div class="chips-help muted">提示：输入以 <code>/</code> 开头可走确定性规则（不走 LLM），如 <code>/observe</code>、<code>/move market</code>、<code>/withdraw 50</code></div>
          </div>
          <div class="card">
            <div class="card-title">任务</div>
            <div class="summary" id="jobsStatus">加载中…</div>
            <ul id="jobsList" class="events"></ul>
          </div>
          <div class="card">
            <div class="card-title">NPC 对话</div>
            <div class="row">
              <select id="npcSelect" class="select"></select>
              <button id="talk">对话</button>
            </div>
            <label class="field">
              <span>对话输入</span>
              <textarea id="npcInput" rows="2" placeholder="询问情报、交易、传闻"></textarea>
            </label>
            <div class="summary" id="npcReply">等待选择 NPC</div>
          </div>
          <div class="card">
            <div class="card-title">世界事件</div>
            <ul id="events" class="events"></ul>
          </div>
          <div class="card">
            <div class="card-title">问题反馈</div>
            <label class="field">
              <span>标题</span>
              <input id="bugTitle" type="text" placeholder="简短说明问题" />
            </label>
            <label class="field">
              <span>描述</span>
              <textarea id="bugDetail" rows="3" placeholder="复现步骤、预期/实际行为"></textarea>
            </label>
            <button id="bugSend">提交给策划</button>
            <div class="summary" id="bugStatus">尚未提交</div>
          </div>
          <div class="card">
            <div class="card-title">地图 / 情报</div>
            <div class="summary" id="mapStatus">仅展示到过或听说过的地点</div>
            <ul id="mapList" class="map-list"></ul>
          </div>
        </section>
      </section>
    </div>
  </main>

  <script type="module">
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");
    const summaryEl = $("summary");
    const sensoryMap = {
      visual: $("vision"),
      audio: $("audio"),
      smell: $("smell"),
      touch: $("touch"),
    };
    const statsEl = {
      hp: $("hp"),
      credits: $("credits"),
      hunger: $("hunger"),
      heat: $("heat"),
      wanted: $("wanted"),
      location: $("location"),
    };

    const locationDetailEl = $("locationDetail");
    const neighborsEl = $("neighbors");

    const npcSelect = $("npcSelect");
    const npcReply = $("npcReply");
    const eventsEl = $("events");
    const bugStatusEl = $("bugStatus");
    const mapList = $("mapList");
    const mapStatus = $("mapStatus");
    const jobsStatus = $("jobsStatus");
    const jobsList = $("jobsList");
    const mapCanvas = $("mapCanvas");
    const mapTooltip = $("mapTooltip");
    const ctx = mapCanvas.getContext("2d");

    let mapData = { rooms: [], connections: [] };
    let npcPositions = [];
    let playerPositions = [];
    let view = { scale: 1, panX: 0, panY: 0 };
    let lastPath = [];
    let hoverRoom = null;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };
    let panOrigin = { x: 0, y: 0 };

    function resizeCanvas() {
      const rect = mapCanvas.getBoundingClientRect();
      mapCanvas.width = Math.max(320, rect.width);
      mapCanvas.height = Math.max(260, rect.height);
    }

    function formatRoom(room, city) {
      if (!room) return "未知地点";
      const zone = room.zone === "city" ? "城市" : "荒野";
      const cityName = city?.name ? ` · ${city.name}` : "";
      return `${room.name || room.id}（${zone}${cityName}）`;
    }

    function renderNeighbors(room) {
      neighborsEl.innerHTML = "";
      const neighbors = room?.neighbors || [];
      if (!neighbors.length) return;
      neighbors.forEach((nbr) => {
        const btn = document.createElement("button");
        btn.className = "chip";
        btn.type = "button";
        btn.textContent = `前往 ${nbr}`;
        btn.addEventListener("click", () => applyPlan({ action: "move", target: nbr, risk: "low" }));
        neighborsEl.appendChild(btn);
      });
    }

    function applyUi(ui) {
      const p = ui?.player;
      const room = ui?.room;
      const city = ui?.city;
      if (!p) return;
      statsEl.hp.textContent = `${p.health ?? "-"}`;
      statsEl.credits.textContent = `${p.credits ?? "-"}`;
      statsEl.hunger.textContent = `${p.hunger ?? "-"}`;
      statsEl.heat.textContent = `${Math.round(p.heat ?? 0)}`;
      statsEl.wanted.textContent = `${p.wantedLevel ?? 0}`;
      statsEl.location.textContent = room?.id || p.location || "-";
      locationDetailEl.textContent = formatRoom(room, city);
      renderNeighbors(room);
    }

    async function loadStatus() {
      const playerId = $("playerId").value.trim() || "demo";
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/status`);
        const json = await res.json();
        if (!res.ok) return;
        applyUi(json);
      } catch (e) {
        console.error(e);
      }
    }

    async function applyPlan(plan) {
      const playerId = $("playerId").value.trim() || "demo";
      setStatus("执行中…", "info");
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/apply`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ plan }),
        });
        const json = await res.json();
        if (!res.ok) {
          setStatus("执行失败", "error");
          summaryEl.textContent = json.error || "执行失败";
          return;
        }
        summaryEl.textContent = json.result?.summary ?? "";
        const sensory = json.result?.sensory ?? {};
        sensoryMap.visual.textContent = sensory.visual || "（无）";
        sensoryMap.audio.textContent = sensory.audio || "（无）";
        sensoryMap.smell.textContent = sensory.smell || "（无）";
        sensoryMap.touch.textContent = sensory.touch || "（无）";
        applyUi(json.ui);
        setStatus("完成", "success");
        loadMap();
        loadJobs();
        loadNpcPositions();
        loadPlayerPositions();
        loadNpcs();
      } catch (e) {
        setStatus(friendlyError((e).message, "执行失败"), "error");
      }
    }

    function parseSlashCommand(text) {
      const t = (text || "").trim();
      if (!t.startsWith("/")) return null;
      const parts = t.slice(1).trim().split(/\s+/);
      const cmd = (parts[0] || "").toLowerCase();
      if (cmd === "observe" || cmd === "look") return { action: "observe", risk: "low" };
      if (cmd === "move" && parts[1]) return { action: "move", target: parts[1], risk: "low" };
      if (cmd === "withdraw" && parts[1]) {
        const n = Number(parts[1]);
        if (Number.isFinite(n)) return { action: "withdraw", amount: n, risk: "med" };
      }
      if (cmd === "attack" && parts[1]) return { action: "attack", target: parts[1], risk: "high" };
      if (cmd === "trade" && parts[1] && parts[2]) {
        const n = Number(parts[2]);
        if (Number.isFinite(n)) return { action: "trade", target: parts[1], amount: n, risk: "med" };
      }
      return { __error: "未知 / 指令。支持：/observe /move <roomId> /withdraw <n> /attack <npcId> /trade <npcId> <n>" };
    }

    async function loadNpcs() {
      const playerId = $("playerId").value.trim() || "demo";
      try {
        const prev = npcSelect.value;
        const res = await fetch(`${baseUrl()}/api/npc?playerId=${encodeURIComponent(playerId)}`);
        const json = await res.json();
        npcSelect.innerHTML = "";
        const list = json.npcs || [];
        if (list.length === 0) {
          const opt = document.createElement("option");
          opt.value = "";
          opt.textContent = "暂无 NPC";
          npcSelect.appendChild(opt);
          npcReply.textContent = "等待统治者/LLM 生成 NPC";
          return;
        }
        list.forEach((n) => {
          const opt = document.createElement("option");
          opt.value = n.id;
          opt.textContent = `${n.name} (${n.role || ""})`;
          npcSelect.appendChild(opt);
        });
        const hasPrev = list.some((n) => n.id === prev);
        if (hasPrev) {
          npcSelect.value = prev;
        } else if (npcSelect.options.length > 0) {
          npcSelect.value = npcSelect.options[0].value;
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function loadEvents() {
      try {
        const res = await fetch(`${baseUrl()}/api/events`);
        const json = await res.json();
        eventsEl.innerHTML = "";
        const list = json.events || [];
        if (list.length === 0) {
          const li = document.createElement("li");
          li.innerHTML = `<div class=\"evt-title\">暂无事件</div><div class=\"evt-detail\">等待统治者/LLM 发布动态…</div>`;
          eventsEl.appendChild(li);
          return;
        }
        list.forEach((evt) => {
          const li = document.createElement("li");
          li.innerHTML = `<div class=\"evt-title\">${evt.title}</div><div class=\"evt-detail\">${evt.detail}</div>`;
          eventsEl.appendChild(li);
        });
      } catch (e) {
        console.error(e);
      }
    }

    function layoutGraph(rooms, centerId) {
      const pos = new Map();
      const center = { x: mapCanvas.width / 2, y: mapCanvas.height / 2 };
      const radiusStep = 90;
      const visited = new Set();
      const queue = [{ id: centerId, depth: 0 }];
      visited.add(centerId);
      pos.set(centerId, center);
      while (queue.length) {
        const { id, depth } = queue.shift();
        const room = rooms.find((r) => r.id === id);
        if (!room) continue;
        const neighbors = room.neighbors || [];
        const angleStep = (Math.PI * 2) / Math.max(1, neighbors.length);
        neighbors.forEach((nbr, idx) => {
          if (visited.has(nbr)) return;
          visited.add(nbr);
          const angle = idx * angleStep;
          const r = (depth + 1) * radiusStep;
          pos.set(nbr, {
            x: center.x + r * Math.cos(angle),
            y: center.y + r * Math.sin(angle),
          });
          queue.push({ id: nbr, depth: depth + 1 });
        });
      }
      // For unseen nodes, scatter them
      rooms.forEach((r, idx) => {
        if (!pos.has(r.id)) {
          const angle = (idx / rooms.length) * Math.PI * 2;
          pos.set(r.id, {
            x: center.x + 220 * Math.cos(angle),
            y: center.y + 220 * Math.sin(angle),
          });
        }
      });
      return pos;
    }
    function withTransform(drawFn) {
      if (!ctx) return;
      ctx.save();
      ctx.translate(mapCanvas.width / 2, mapCanvas.height / 2);
      ctx.scale(view.scale, view.scale);
      ctx.translate(view.panX, view.panY);
      ctx.translate(-mapCanvas.width / 2, -mapCanvas.height / 2);
      drawFn();
      ctx.restore();
    }

    function drawPath(positions, path) {
      if (!ctx || !path || path.length < 2) return;
      ctx.beginPath();
      ctx.strokeStyle = "#f97316";
      ctx.lineWidth = 3;
      path.forEach((rid, idx) => {
        const p = positions.get(rid);
        if (!p) return;
        if (idx === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();
    }

    function drawHover(positions) {
      if (!hoverRoom || !ctx) return;
      const p = positions.get(hoverRoom);
      if (!p) return;
      ctx.beginPath();
      ctx.strokeStyle = "#fde68a";
      ctx.lineWidth = 2.5;
      ctx.setLineDash([6, 4]);
      ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawMap() {
      if (!ctx) return;
      ctx.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
      const playerId = $("playerId").value.trim() || "demo";
      const playerRoom = statsEl.location.textContent || (mapData.rooms[0]?.id ?? "");
      const positions = layoutGraph(mapData.rooms, playerRoom);

      withTransform(() => {
        // Edges
        ctx.strokeStyle = "#1f2937";
        ctx.lineWidth = 1;
        mapData.rooms.forEach((r) => {
          const p = positions.get(r.id);
          r.neighbors?.forEach((n) => {
            const q = positions.get(n);
            if (p && q) {
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(q.x, q.y);
              ctx.stroke();
            }
          });
        });

        // Highlight path
        drawPath(positions, lastPath);
        drawHover(positions);

        // Rooms
        mapData.rooms.forEach((r) => {
          const p = positions.get(r.id);
          if (!p) return;
          const isPlayerRoom = r.id === playerRoom;
          ctx.beginPath();
          ctx.fillStyle = isPlayerRoom ? "#22c55e" : r.zone === "city" ? "#38bdf8" : "#8b5cf6";
          ctx.arc(p.x, p.y, isPlayerRoom ? 10 : 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#e2e8f0";
          ctx.font = "12px Inter, sans-serif";
          ctx.fillText(r.name || r.id, p.x + 10, p.y + 4);
        });

        // NPCs
        npcPositions.forEach((n) => {
          const p = positions.get(n.location);
          if (!p) return;
          ctx.beginPath();
          ctx.fillStyle = "#3b82f6";
          ctx.arc(p.x, p.y - 14, 5, 0, Math.PI * 2);
          ctx.fill();
        });

        // Other players
        playerPositions.forEach((pl) => {
          if (pl.id === playerId) return;
          const p = positions.get(pl.location);
          if (!p) return;
          ctx.beginPath();
          ctx.fillStyle = "#f59e0b";
          ctx.arc(p.x, p.y + 14, 5, 0, Math.PI * 2);
          ctx.fill();
        });
      });
    }

    function shortestPath(rooms, start, target) {
      const adj = new Map();
      rooms.forEach((r) => adj.set(r.id, r.neighbors || []));
      const queue = [start];
      const prev = new Map([[start, null]]);
      while (queue.length) {
        const cur = queue.shift();
        if (cur === target) break;
        (adj.get(cur) || []).forEach((n) => {
          if (!prev.has(n)) {
            prev.set(n, cur);
            queue.push(n);
          }
        });
      }
      if (!prev.has(target)) return [];
      const path = [];
      let cur = target;
      while (cur) {
        path.push(cur);
        cur = prev.get(cur);
      }
      return path.reverse();
    }

    function screenToWorld(mx, my) {
      return {
        x: (mx - mapCanvas.width / 2) / view.scale - view.panX + mapCanvas.width / 2,
        y: (my - mapCanvas.height / 2) / view.scale - view.panY + mapCanvas.height / 2,
      };
    }

    function graphBounds(positions) {
      const points = Array.from(positions.values());
      if (!points.length) return null;
      let minX = points[0].x, maxX = points[0].x, minY = points[0].y, maxY = points[0].y;
      points.forEach(({ x, y }) => {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      });
      return { minX, maxX, minY, maxY };
    }

    function fitView() {
      const playerRoom = statsEl.location.textContent || (mapData.rooms[0]?.id ?? "");
      const positions = layoutGraph(mapData.rooms, playerRoom);
      const bounds = graphBounds(positions);
      if (!bounds) return;
      const padding = 60;
      const width = bounds.maxX - bounds.minX + padding * 2;
      const height = bounds.maxY - bounds.minY + padding * 2;
      const scaleX = mapCanvas.width / width;
      const scaleY = mapCanvas.height / height;
      view.scale = Math.min(2.5, Math.max(0.5, Math.min(scaleX, scaleY)));
      const centerX = (bounds.minX + bounds.maxX) / 2;
      const centerY = (bounds.minY + bounds.maxY) / 2;
      view.panX = ((mapCanvas.width / 2 - centerX) / view.scale) - (mapCanvas.width / 2 - centerX) / 1;
      view.panY = ((mapCanvas.height / 2 - centerY) / view.scale) - (mapCanvas.height / 2 - centerY) / 1;
    }

    function centerOnPlayer() {
      const playerRoom = statsEl.location.textContent || (mapData.rooms[0]?.id ?? "");
      const positions = layoutGraph(mapData.rooms, playerRoom);
      const p = positions.get(playerRoom);
      if (!p) return;
      view.panX = ((mapCanvas.width / 2 - p.x) / view.scale) - (mapCanvas.width / 2 - p.x) / 1;
      view.panY = ((mapCanvas.height / 2 - p.y) / view.scale) - (mapCanvas.height / 2 - p.y) / 1;
    }

    function resetView() {
      view = { scale: 1, panX: 0, panY: 0 };
    }

    function getRoomStats(roomId) {
      const npcCount = npcPositions.filter((n) => n.location === roomId).length;
      const playerCount = playerPositions.filter((p) => p.location === roomId).length;
      const room = mapData.rooms.find((r) => r.id === roomId);
      return { npcCount, playerCount, room };
    }

    function updateTooltip(roomId, mx, my) {
      if (!mapTooltip) return;
      const { npcCount, playerCount, room } = getRoomStats(roomId);
      mapTooltip.style.display = "block";
      mapTooltip.style.left = `${mx}px`;
      mapTooltip.style.top = `${my}px`;
      mapTooltip.innerHTML = `
        <strong>${room?.name || roomId}</strong>
        <div class="muted">ID: ${roomId} · 区域: ${room?.zone || "未知"}</div>
        <div>NPC: ${npcCount} · 玩家: ${playerCount}</div>
        <div>邻接: ${(room?.neighbors || []).join("、") || "无"}</div>
      `;
    }

    function hideTooltip() {
      if (!mapTooltip) return;
      mapTooltip.style.display = "none";
    }

    function handleMapClick(e) {
      if (!mapData.rooms.length) return;
      const rect = mapCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const { x: worldX, y: worldY } = screenToWorld(mx, my);
      const playerRoom = statsEl.location.textContent || (mapData.rooms[0]?.id ?? "");
      const positions = layoutGraph(mapData.rooms, playerRoom);
      let best = null;
      mapData.rooms.forEach((r) => {
        const p = positions.get(r.id);
        if (!p) return;
        const d = Math.hypot(p.x - worldX, p.y - worldY);
        if (best === null || d < best.d) best = { id: r.id, d };
      });
      if (best && best.d < 30) {
        lastPath = shortestPath(mapData.rooms, playerRoom, best.id);
        applyPlan({ action: "move", target: best.id, risk: "low" });
        drawMap();
      }
    }

    function handleHover(e) {
      if (!mapData.rooms.length) return;
      const rect = mapCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const { x: worldX, y: worldY } = screenToWorld(mx, my);
      const playerRoom = statsEl.location.textContent || (mapData.rooms[0]?.id ?? "");
      const positions = layoutGraph(mapData.rooms, playerRoom);
      let best = null;
      mapData.rooms.forEach((r) => {
        const p = positions.get(r.id);
        if (!p) return;
        const d = Math.hypot(p.x - worldX, p.y - worldY);
        if (best === null || d < best.d) best = { id: r.id, d, p };
      });
      if (best && best.d < 30) {
        if (hoverRoom !== best.id) {
          hoverRoom = best.id;
          updateTooltip(best.id, mx, my);
          drawMap();
        } else {
          updateTooltip(best.id, mx, my);
        }
      } else {
        if (hoverRoom) {
          hoverRoom = null;
          hideTooltip();
          drawMap();
        }
      }
    }

    async function sendBug() {
      const title = $("bugTitle").value.trim();
      const detail = $("bugDetail").value.trim();
      const playerId = $("playerId").value.trim() || undefined;
      if (!title || !detail) {
        bugStatusEl.textContent = "请填写标题和描述";
        return;
      }
      bugStatusEl.textContent = "提交中…";
      try {
        const res = await fetch(`${baseUrl()}/api/bug-report`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ title, detail, playerId }),
        });
        const json = await res.json();
        if (!res.ok) {
          bugStatusEl.textContent = json.error || `提交失败 (${res.status})`;
          return;
        }
        bugStatusEl.textContent = `已提交 (${json.id || "已记录"})`;
        setStatus("Bug 已提交给策划", "info");
      } catch (e) {
        bugStatusEl.textContent = (e).message;
      }
    }

    async function loadMap() {
      const playerId = $("playerId").value.trim() || "demo";
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/map`);
        const json = await res.json();
        mapList.innerHTML = "";
        const rooms = json.rooms || [];
        mapData.rooms = rooms;
        lastPath = [];
        if (rooms.length === 0) {
          mapStatus.textContent = "暂无可见区域，尝试观察或移动探索。";
          return;
        }
        mapStatus.textContent = "仅展示到过或听说过的地点";
        rooms.forEach((r) => {
          const li = document.createElement("li");
          const tag = document.createElement("span");
          tag.className = `tag ${r.status === "visited" ? "visited" : "known"}`;
          tag.textContent = r.status === "visited" ? "到访" : "听闻";
          const name = document.createElement("span");
          name.className = "map-name";
          name.textContent = `${r.name} (${r.id})`;
          const neighbors = document.createElement("div");
          neighbors.className = "map-neighbors";
          neighbors.textContent = `可达：${(r.neighbors || []).join("、") || "未知"}`;
          li.appendChild(tag);
          li.appendChild(name);
          li.appendChild(neighbors);
          mapList.appendChild(li);
        });
        drawMap();
      } catch (e) {
        mapStatus.textContent = (e).message;
      }
    }

    async function loadNpcPositions() {
      try {
        const res = await fetch(`${baseUrl()}/api/npc?scope=all`);
        const json = await res.json();
        npcPositions = (json.npcs || []).map((n) => ({ id: n.id, location: n.location }));
        drawMap();
      } catch (e) {
        console.error(e);
      }
    }

    async function loadPlayerPositions() {
      try {
        const res = await fetch(`${baseUrl()}/api/players`);
        const json = await res.json();
        playerPositions = json.players || [];
        drawMap();
      } catch (e) {
        console.error(e);
      }
    }

    async function loadJobs() {
      const playerId = $("playerId").value.trim() || "demo";
      jobsStatus.textContent = "加载中…";
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/jobs`);
        const json = await res.json();
        if (!res.ok) {
          jobsStatus.textContent = json.error || `加载失败 (${res.status})`;
          return;
        }
        const jobs = json.jobs || [];
        jobsList.innerHTML = "";
        if (!jobs.length) {
          jobsStatus.textContent = `当前位置：${json.location || "-"} · 热度：${Math.round(json.heat || 0)} · 通缉：${json.wantedLevel ?? 0}`;
          return;
        }
        jobsStatus.textContent = `当前位置：${json.location} · 热度：${Math.round(json.heat || 0)} · 通缉：${json.wantedLevel ?? 0}`;
        jobs.forEach((j) => {
          const li = document.createElement("li");
          const disabled = !j.available;
          li.innerHTML = `
            <div class="evt-title">${j.title} <span class="muted">(${j.type})</span></div>
            <div class="evt-detail">${j.summary}</div>
            <div class="evt-detail">奖励：${j.creditReward} · 热度：${j.heatDelta > 0 ? "+" : ""}${j.heatDelta} · 冷却：${j.cooldownSec}s${disabled ? ` · 不可用：${j.reason || "-"}` : ""}</div>
            <div class="row" style="margin: 8px 0 0;">
              <button class="ghost" data-job-run="${j.id}" ${disabled ? "disabled" : ""}>执行</button>
            </div>
          `;
          jobsList.appendChild(li);
        });
      } catch (e) {
        jobsStatus.textContent = (e).message;
      }
    }

    async function runJob(jobId) {
      const playerId = $("playerId").value.trim() || "demo";
      setStatus("执行任务中…", "info");
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/job`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ jobId }),
        });
        const json = await res.json();
        if (!res.ok) {
          setStatus("任务失败", "error");
          summaryEl.textContent = json.error || "任务失败";
          return;
        }
        const result = json.result;
        summaryEl.textContent = result?.summary ?? "";
        const sensory = result?.sensory ?? {};
        sensoryMap.visual.textContent = sensory.visual || "（无）";
        sensoryMap.audio.textContent = sensory.audio || "（无）";
        sensoryMap.smell.textContent = sensory.smell || "（无）";
        sensoryMap.touch.textContent = sensory.touch || "（无）";
        const state = result?.state;
        if (state) {
          statsEl.hp.textContent = `${state.health}`;
          statsEl.credits.textContent = `${state.credits}`;
          statsEl.hunger.textContent = `${state.hunger ?? "-"}`;
          statsEl.heat.textContent = `${Math.round(state.heat ?? 0)}`;
          statsEl.location.textContent = state.location;
        }
        setStatus("任务完成", "success");
        loadStatus();
        loadJobs();
        loadMap();
        loadNpcPositions();
        loadPlayerPositions();
      } catch (e) {
        setStatus(friendlyError((e).message, "任务失败"), "error");
      }
    }

    function setStatus(text, tone = "info") {
      statusEl.textContent = text;
      statusEl.dataset.tone = tone;
    }

    function friendlyError(message, fallback = "请求失败") {
      if (!message) return fallback;
      const lower = message.toLowerCase();
      if (lower.includes("failed to fetch") || lower.includes("network")) return `${fallback}：网络异常`;
      if (lower.startsWith("http")) return `${fallback}：服务不可用`;
      return `${fallback}：${message}`;
    }

    function baseUrl() {
      const v = $("server").value.trim();
      return v || `${window.location.origin}`;
    }

    async function doHealth() {
      setStatus("检查中…", "info");
      try {
        const res = await fetch(`${baseUrl()}/health`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        setStatus(`健康: ${json.status}`, "success");
      } catch (e) {
        setStatus(friendlyError((e).message, "健康检查失败"), "error");
      }
    }

    async function send() {
      const input = $("input").value.trim();
      const playerId = $("playerId").value.trim() || "demo";
      if (!input) {
        setStatus("请输入内容", "error");
        return;
      }

      const parsed = parseSlashCommand(input);
      if (parsed?.__error) {
        setStatus(parsed.__error, "error");
        return;
      }
      if (parsed) {
        $("input").value = "";
        await applyPlan(parsed);
        return;
      }

      setStatus("请求中…", "info");
      try {
        const res = await fetch(`${baseUrl()}/api/session/${encodeURIComponent(playerId)}/act`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input }),
        });
        const json = await res.json();
        if (!res.ok) {
          setStatus("执行失败，请稍后再试", "error");
          summaryEl.textContent = json.error || "执行失败";
          return;
        }
        summaryEl.textContent = json.result?.summary ?? "";
        const sensory = json.result?.sensory ?? {};
        sensoryMap.visual.textContent = sensory.visual || "（无）";
        sensoryMap.audio.textContent = sensory.audio || "（无）";
        sensoryMap.smell.textContent = sensory.smell || "（无）";
        sensoryMap.touch.textContent = sensory.touch || "（无）";
        const state = json.result?.state;
        if (state) {
          statsEl.hp.textContent = `${state.health}`;
          statsEl.credits.textContent = `${state.credits}`;
          statsEl.hunger.textContent = `${state.hunger ?? "-"}`;
          statsEl.heat.textContent = `${Math.round(state.heat ?? 0)}`;
          statsEl.location.textContent = state.location;
        }
        applyUi(json.ui);
        if (!res.ok) {
          return;
        }
        setStatus("完成", "success");
        loadMap();
        loadJobs();
        loadStatus();
      } catch (e) {
        setStatus(friendlyError((e).message), "error");
      }
    }

    mapCanvas.style.cursor = "grab";
    mapCanvas.addEventListener("click", handleMapClick);
    mapCanvas.addEventListener("mousemove", handleHover);
    mapCanvas.addEventListener("mouseleave", () => { hoverRoom = null; hideTooltip(); drawMap(); });
    mapCanvas.addEventListener("dblclick", () => { fitView(); drawMap(); });
    mapCanvas.addEventListener("mousedown", (e) => {
      isPanning = true;
      panStart = { x: e.clientX, y: e.clientY };
      panOrigin = { x: view.panX, y: view.panY };
      mapCanvas.style.cursor = "grabbing";
    });
    mapCanvas.addEventListener("mousemove", (e) => {
      if (!isPanning) return;
      const dx = (e.clientX - panStart.x) / view.scale;
      const dy = (e.clientY - panStart.y) / view.scale;
      view.panX = panOrigin.x + dx;
      view.panY = panOrigin.y + dy;
      drawMap();
    });
    const stopPan = () => {
      isPanning = false;
      mapCanvas.style.cursor = "grab";
    };
    mapCanvas.addEventListener("mouseup", stopPan);
    mapCanvas.addEventListener("mouseleave", stopPan);
    mapCanvas.addEventListener(
      "wheel",
      (e) => {
        e.preventDefault();
        const rect = mapCanvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const worldBefore = screenToWorld(mx, my);
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        view.scale = Math.min(3, Math.max(0.5, view.scale * factor));
        // Keep zoom centered around the cursor
        view.panX = (mx - mapCanvas.width / 2) / view.scale - worldBefore.x + mapCanvas.width / 2;
        view.panY = (my - mapCanvas.height / 2) / view.scale - worldBefore.y + mapCanvas.height / 2;
        drawMap();
      },
      { passive: false },
    );

    $("send").addEventListener("click", send);
    $("health").addEventListener("click", doHealth);
    $("clear").addEventListener("click", () => {
      summaryEl.textContent = "等待输入…";
      Object.values(sensoryMap).forEach((el) => (el.textContent = ""));
      Object.values(statsEl).forEach((el) => (el.textContent = "-"));
      locationDetailEl.textContent = "-";
      neighborsEl.innerHTML = "";
      setStatus("已清空", "info");
    });

    $("refreshNpc").addEventListener("click", loadNpcs);
    $("refreshMap").addEventListener("click", () => { loadMap(); loadNpcPositions(); loadPlayerPositions(); });
    $("bugSend").addEventListener("click", sendBug);
    $("mapFocus").addEventListener("click", () => { centerOnPlayer(); drawMap(); });
    $("mapFit").addEventListener("click", () => { fitView(); drawMap(); });
    $("mapReset").addEventListener("click", () => { resetView(); drawMap(); });
    $("talk").addEventListener("click", async () => {
      const npcId = npcSelect.value;
      const input = $("npcInput").value.trim();
      const playerId = $("playerId").value.trim() || "demo";
      if (!npcId) {
        npcReply.textContent = "请先选择 NPC";
        return;
      }
      if (!input) {
        npcReply.textContent = "请输入对话";
        return;
      }
      try {
        const res = await fetch(`${baseUrl()}/api/npc/${encodeURIComponent(npcId)}/talk`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ input, playerId }),
        });
        const json = await res.json();
        if (!res.ok) {
          npcReply.textContent = json.error || "对话失败";
          return;
        }
        const replyText = json.reply?.reply || json.reply || "";
        const actionSummary = json.reply?.actionResult?.summary;
        npcReply.textContent = actionSummary ? `${replyText}\n[行动]: ${actionSummary}` : replyText;
      } catch (e) {
        npcReply.textContent = (e).message;
      }
    });

    jobsList.addEventListener("click", (e) => {
      const btn = e.target.closest?.("button[data-job-run]");
      if (!btn) return;
      const jobId = btn.getAttribute("data-job-run");
      if (!jobId) return;
      runJob(jobId);
    });

    $("input").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        send();
      }
    });

    resizeCanvas();
    fitView();
    window.addEventListener("resize", () => {
      resizeCanvas();
      fitView();
      drawMap();
    });
    setStatus("准备就绪", "success");
    loadStatus();
    loadNpcs();
    loadEvents();
    loadMap();
    loadJobs();
    loadNpcPositions();
    loadPlayerPositions();
    setInterval(loadNpcs, 15000);
    setInterval(loadEvents, 15000);
    setInterval(() => { loadNpcPositions(); loadPlayerPositions(); }, 15000);
  </script>
</body>
</html>
